name: Update Windows ISO Links

# Run daily + manual trigger
on:
  schedule:
    - cron: '0 0 * * *'  # Execute daily at UTC 00:00
  workflow_dispatch:  # Manual trigger

permissions:
  contents: write  # Allow workflow to push back to repository

jobs:
  fetch-fido:
    runs-on: windows-latest

    steps:
      # 1. Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2. Download the latest Fido.ps1
      - name: Download Fido.ps1
        run: |
          # NOTE:
          # PowerShell's 'curl' is just an alias of Invoke-WebRequest, which does NOT support '-L'.
          # On GitHub Actions, any command that goes through the Runner's built-in HttpClient
          # (e.g., Invoke-WebRequest / Invoke-RestMethod) is subject to a strict ~30s timeout.
          # This often causes downloads to fail under PowerShell on GitHub runners.
          # To avoid the HttpClient proxy and ensure stable downloads, use curl.exe instead.
          #
          # Previous example:
          # Invoke-WebRequest -Uri "https://raw.githubusercontent.com/pbatard/Fido/master/Fido.ps1" -OutFile "Fido.ps1"
          curl.exe -L "https://raw.githubusercontent.com/pbatard/Fido/master/Fido.ps1" -o Fido.ps1

      # 3. Run Fido.ps1 and save output to a file
      - name: Run Fido.ps1 and save output
        env:
          DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: ${{ env.GITHUB_ACTIONS == 'true' && '0' || '1' }}
          # DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: 0
          ACTIONS_NET_HTTP_CLIENT_TIMEOUT: "120000"
        shell: pwsh
        run: |
          Write-Host "Fetching Windows 11 ISO link..."

          $maxRetries = 5
          $retryDelay = 5
          $success = $false

          for ($i = 1; $i -le $maxRetries; $i++) {
              try{
                  Write-Host "Attempt $i of $maxRetries..."
                  $link = & ".\Fido.ps1" -Win 'Windows 11' -Rel Latest -Ed 'Windows 11 Home/Pro/Edu' -Lang English -Arch x64 -GetUrl

                  if ($link) {
                      Write-Host "Success! Got link: $link"
                      $success = $true
                      break
                  }
                  else {
                      throw "Fido.ps1 returned empty result."
                  }

              } catch {
                  Write-Host "Attempt $i failed: $_"
                  if ($i -lt $maxRetries) {
                      Write-Host "Retrying in $retryDelay seconds..."
                      Start-Sleep -Seconds $retryDelay
                  }
              }
          }

          if (-not $success) {
              throw "Fido.ps1 failed after $maxRetries attempts."
          }

          $link | Out-File -FilePath "windows_iso_links.txt" -Encoding UTF8

      # 4. Fetch English 64-bit SHA256 from Microsoft's official page
      - name: Fetch Microsoft official SHA256
        shell: pwsh
        run: |
          $url = "https://www.microsoft.com/en-us/software-download/windows11"
          $html = Invoke-WebRequest $url
          if ($html.Content -match '<td>English 64-bit</td><td>([A-F0-9]{64})</td>') {
              # Convert SHA256 to lowercase for later checksum comparison
              $sha256 = $matches[1].ToLower()
              Write-Host "English 64-bit SHA256: $sha256"
              $sha256 | Out-File -FilePath "sha256.txt" -Encoding UTF8
          } else {
              Write-Error "Failed to parse SHA256"
          }

      # 5. Fetch ISO file size (MB)
      - name: Fetch ISO size
        shell: pwsh
        run: |
          $link = Get-Content "windows_iso_links.txt"
          $response = Invoke-WebRequest -Uri $link -Method Head

          $cl = $response.Headers["Content-Length"]
          # Content-Length may sometimes be returned as a string array (System.String[]),  
          # so pick the first element to ensure it can be safely converted to Int64.
          if ($cl -is [array]) { $cl = $cl[0] }
          $sizeBytes = [int64]$cl
          $sizeMB = [math]::Ceiling($sizeBytes / 1MB)
          Write-Host "ISO Size (MB): $sizeMB"
          $sizeMB | Out-File -FilePath "size_mb.txt" -Encoding UTF8

      # 6. Combine all values into a JSON file for easy script consumption
      - name: Combine all info into one JSON file
        shell: pwsh
        run: |
          $link = Get-Content "windows_iso_links.txt"
          $sha256 = Get-Content "sha256.txt"
          $sizeMB = Get-Content "size_mb.txt"

          $json = [PSCustomObject]@{
              download_link = $link
              sha256 = $sha256
              size_mb = $sizeMB
              updated_at = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
          } | ConvertTo-Json -Depth 3

          # Make sure data directory exists
          if (-not (Test-Path "data")) { New-Item -ItemType Directory -Path "data" }

          # Output JSON into data/
          $json | Out-File -FilePath "data/win11_info.json" -Encoding UTF8
 
      # 7. Commit and push updates to the repository
      - name: Commit and push
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Update Win11 link, SHA256 & size"
          # ">" means folded block style â€” it converts the following multiple lines
          # into a single space-separated string so git-auto-commit-action receives them correctly.
          # Previously considered uploading these files. At that time, `>` was needed for multi-line input.
          # Now replaced by the single consolidated file `win11_info.json`.
          # windows_iso_links.txt
          # sha256.txt
          # size_mb.txt
          file_pattern: >
            data/win11_info.json
